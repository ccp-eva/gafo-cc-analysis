// example call: time webppl gafo-cc-model-hier-extended.wppl --require webppl-json --require webppl-sample-writer 1

var chain = last(process.argv)

// helper functions

var foreach = function(fn, lst) {
    var foreach_ = function(i) {
        if (i < lst.length) {
            fn(lst[i]);
            foreach_(i + 1);
        }
    };
    foreach_(0);
};

var samplePosGaussian = function(mu, sigma) {
    var x = sample(Gaussian({ mu: mu, sigma: sigma }))
    return x < 0 ? samplePosGaussian(mu, sigma) : x
};

var logistic = function(x) { 1 / (1 + Math.exp(-x)) }

var multiply = function(x, y) { return x * y; };

var levels = function(df, label) {
    return _.uniq(_.map(df, label));
}

var deg2rad = function(x) {
    (x * Math.pi) / (180)
}


// data

//var data = json.read('model_data/gafo-cc-model-data-sim01-small.json');
var data = json.read('model_data/gafo-cc-model-data.json');

//var trialtypes = levels(data, "trialtype")

var communities = levels(data, "community")

//var subjects = levels(comdata, "subjid")

//display(communities)

var maxcoord = 2920

var granularity = 20

var grancoord = maxcoord / granularity

var cords = _.range(0, grancoord)

var samplecoord = map(function(x) {
    return x * granularity;
}, cords)

var centerbias = json.read('model_data/centerBias_extended.json');

//var coordinates = _.range(0, 2920)

var scale = 500

var model = function() {

    var globalinfint = gaussianDrift({ mu: -2, sigma: 1, width: 0.1 })
    var globalinfslope = gaussianDrift({ mu: 0, sigma: 0.5, width: 0.1 })
    var globalinfsigmaint = uniformDrift({ a: 0, b: 1, width: 0.1 })
    var globalinfsigmaslope = uniformDrift({ a: 0, b: 1, width: 0.1 })

    var globalguessint = gaussianDrift({ mu: -2, sigma: 1, width: 0.1 })
    var globalguessslope = gaussianDrift({ mu: 0, sigma: 0.5, width: 0.1 })
    var globalguesssigmaint = uniformDrift({ a: 0, b: 1, width: 0.1 })
    var globalguesssigmaslope = uniformDrift({ a: 0, b: 1, width: 0.1 })

    var globalbiasint = gaussianDrift({ mu: 0, sigma: 0.5, width: 0.1 })
    var globalbiasslope = gaussianDrift({ mu: 0, sigma: 0.5, width: 0.1 })
    var globalbiassigmaint = uniformDrift({ a: 0, b: 1, width: 0.1 })
    var globalbiassigmaslope = uniformDrift({ a: 0, b: 1, width: 0.1 })


    foreach(function(community) {

        var cominfint = gaussianDrift({ mu: globalinfint, sigma: globalinfsigmaint, width: 0.1 })
        var cominfslope = gaussianDrift({ mu: globalinfslope, sigma: globalinfsigmaslope, width: 0.1 })
        var cominfsigma = uniformDrift({ a: 0, b: 2, width: 0.1 })
        
        var comguessint = gaussianDrift({ mu: globalguessint, sigma: globalguesssigmaint, width: 0.1 })
        var comguessslope = gaussianDrift({ mu: globalguessslope, sigma: globalguesssigmaslope, width: 0.1 })
        var comguesssigma = uniformDrift({ a: 0, b: 2, width: 0.1 })

        var combiasint = gaussianDrift({ mu: globalbiasint, sigma: globalbiassigmaint, width: 0.1 })
        var combiasslope = gaussianDrift({ mu: globalbiasslope, sigma: globalbiassigmaslope, width: 0.1 })

        //var comdata = _.filter(data, { community: community })

        //display(comdata)

        var subjects = levels(_.filter(data, {community: community }), "subjid")

        //display(subjects)

        foreach(function(subjid) {

            //var guess = uniformDrift({a: 0, b:1, width: 0.1})

            var iddata = _.filter(data, { subjid: subjid , community: community })

            var age = iddata[0].agecentered

            var sdinfage = cominfint + cominfslope * age
            var sdinfsamp = gaussianDrift({ mu: sdinfage, sigma: cominfsigma, width: 0.1 })
            var sdinfid = logistic(sdinfsamp)
            //var sdinfid = logistic(gaussianDrift({ mu: 0, sigma: 1, width: 0.1 }))
            //var sdinfid = 0.1

            var guessage = comguessint + comguessslope * age
            var guesssamp = gaussianDrift({ mu: guessage, sigma: comguesssigma, width: 0.1 })
            var guess = logistic(guesssamp)
            
            var biasage = combiasint + combiasslope * age
            var bias = logistic(biasage)

            //display(iddata)

            foreach(function(row) {


                //var click = row.clickscaledx
                var click = Math.round((row.clickscaledx+scale)/granularity)*granularity
                //var model_click = Math.round((row.model_click)/granularity)*granularity
                //display(click)
                //var targetposition = row.targetposition
                //var targetcenterx = row.targetcenterx
                var targetcentery = row.targetcentery
                var eyecenterlx = row.eyecenterleftx+scale
                var eyecenterly = row.eyecenterlefty
                var eyecenterrx = row.eyecenterrightx+scale
                var eyecenterry = row.eyecenterrighty
                var pupillx = row.pupilfinalleftx+scale
                var pupilly = row.pupilfinallefty
                var pupilrx = row.pupilfinalrightx+scale
                var pupilry = row.pupilfinalrighty

                var talphal = eyecenterlx > pupillx ?
                    Math.atan(Math.abs(eyecenterlx - pupillx) / (eyecenterly - pupilly)) :
                    (-Math.atan(Math.abs(eyecenterlx - pupillx) / (eyecenterly - pupilly)))

                var talphar = eyecenterrx > pupilrx ?
                    Math.atan(Math.abs(eyecenterrx - pupilrx) / (eyecenterry - pupilry)) :
                    (-Math.atan(Math.abs(eyecenterrx - pupilrx) / (eyecenterry - pupilry)))

                //var  noisyalphal = gaussian(talphal, sdper)

                //var  noisyalphar = gaussian(talphar, sdper)


                //display([talphal,talphar])

                var ldist = map(function(coord) {

                    var betal = eyecenterlx > coord ?
                        Math.atan(Math.abs(eyecenterlx - coord) / (eyecenterly - targetcentery)) :
                        (-Math.atan(Math.abs(eyecenterlx - coord) / (eyecenterly - targetcentery)))

                    //var betaldist = Gaussian({mu:noisyalphal,sigma:sdinf}).score(betal)
                    var betaldist = Gaussian({ mu: talphal, sigma: sdinfid }).score(betal)

                    return betaldist

                }, samplecoord)

                var rdist = map(function(coord) {

                    var betar = eyecenterrx > coord ?
                        Math.atan(Math.abs(eyecenterrx - coord) / (eyecenterry - targetcentery)) :
                        (-Math.atan(Math.abs(eyecenterrx - coord) / (eyecenterry - targetcentery)))

                    //var betardist = Gaussian({mu:noisyalphar,sigma:sdinf}).score(betar)
                    var betardist = Gaussian({ mu: talphar, sigma: sdinfid }).score(betar)

                    return betardist

                }, samplecoord)


                var lnormdist = map(function(x) {
                    var lnormdist = Math.exp(x - util.logsumexp(ldist))
                    return lnormdist
                }, ldist)


                var rnormdist = map(function(x) {
                    var rnormdist = Math.exp(x - util.logsumexp(rdist))
                    return rnormdist
                }, rdist)

                var xdist = map2(multiply, lnormdist, rnormdist)

                //query.add([subjid,sdinfid,targetcenterx+scale], xdist)

                //display(samplecoord)

                                // var xcoorddist = map(function(x) {
                //     return repeat(granularity, function() { return x; })
                // }, xdist)

                var gazepred = Categorical({ ps: xdist, vs: samplecoord })

                

               //display(gazepred)

                //var pred = flip(guess) ? flip(bias) ? Categorical({ ps: centerbias, vs: samplecoord }) : Uniform({ a: 500, b: 2420 }) : gazepred

                
                //display(pred)

                observe(gazepred, click)

                //observe(gazepred, model_click)

                //var predsample = sample(pred)

                //query.add(["inference","prediction",targetposition,targetcenterx], sample(pred))
                //display(guess)

                //},testdata)
            }, iddata)

            query.add([chain, "inference", "sd", "id", subjid, community], sdinfid)
            query.add([chain, "guessing ", "guess", "id", subjid, community], guess)
            query.add([chain, "bias ", "bias", "id", subjid, community], bias)


        }, subjects)

        query.add([chain, "inference", "sigma", "community", "na", community], cominfsigma)
        query.add([chain, "inference", "intercept", "community", "na", community], cominfint)
        query.add([chain, "inference", "slope", "community", "na", community], cominfslope)

        query.add([chain, "guessing", "sigma", "community", "na", community], comguesssigma)
        query.add([chain, "guessing", "intercept", "community", "na", community], comguessint)
        query.add([chain, "guessing", "slope", "community", "na", community], comguessslope)

        query.add([chain, "bias", "intercept", "community", "na", community], combiasint)
        query.add([chain, "bias", "slope", "community", "na", community], combiasslope)




    }, communities)

    query.add([chain, "inference", "intercept", "global", "na", "na"], globalinfint)
    query.add([chain, "inference", "slope", "global", "na", "na"], globalinfslope)
    query.add([chain, "inference", "sigma_intercept", "global", "na", "na"], globalinfsigmaint)
    query.add([chain, "inference", "sigma_slope", "global", "na", "na"], globalinfsigmaslope)

    query.add([chain, "guessing", "intercept", "global", "na", "na"], globalguessint)
    query.add([chain, "guessing", "slope", "global", "na", "na"], globalguessslope)
    query.add([chain, "guessing", "sigma_intercept", "global", "na", "na"], globalguesssigmaint)
    query.add([chain, "guessing", "sigma_slope", "global", "na", "na"], globalguesssigmaslope)

    query.add([chain, "bias", "intercept", "global", "na", "na"], globalbiasint)
    query.add([chain, "bias", "slope", "global", "na", "na"], globalbiasslope)
    query.add([chain, "bias", "sigma_intercept", "global", "na", "na"], globalbiassigmaint)
    query.add([chain, "bias", "sigma_slope", "global", "na", "na"], globalbiassigmaslope)

    return query

}

var header = "iteration,chain,parameter,type,scope,id, community,value,score"

//var header = "iteration,subject,sd, target,value"

var output_file = 'output/gafo-cc-hier_extended_gran_' + granularity + '_chain' + chain + '.csv'
var callback = webpplSampleWriter.streamQueryCSV(output_file, header);

var output = Infer({
    model,
    samples: 25000,//50000,
    burn: 50000, //100000,
    lag: 1,
    method: 'MCMC',
    verbose: T,
    callbacks: [callback]
});